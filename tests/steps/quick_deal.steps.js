// tests/steps/quick_deal.steps.jsconst { Given, When } = require('@cucumber/cucumber');const { format } = require('../../src/utils/dateUtil.js');const { UI } = require('../../src/utils/ui');const fake = require('../../src/utils/fakerUtil');const Data = require('../../src/utils/data');const { getPrimaryApplicantForScenario, getApplicantDetail } = require('../../src/data/domain/applicant.js');/* ----------------------- Quick Deal (initial) ----------------------- */Given('I fill the initial application details', async function () {  const attach = typeof this.attach === 'function' ? this.attach.bind(this) : async () => {};  const ui = new UI(this.page, attach);  const scenarioID = this?.testData?.ScenarioID || this?.data?.context?.ScenarioID;  const dealSheet = this?.testData?.ScenarioSheet || 'EndToEnd';  const { bag: primary, casl } = await getPrimaryApplicantForScenario(this, scenarioID, { dealSheet });  const first = Data.get(primary, 'FirstName') || fake.getFirstName();  const last = Data.get(primary, 'LastName') || fake.getLastName();  await attach(`Initial applicant: first="${first}", last="${last}", casl=${!!casl}`);  await ui.fill('quick.firstName', first);  await ui.fill('quick.lastName', last);  try { await ui.check('quick.casl.checkbox', casl); } catch {}  const closing = this?.__dealRow?.ClosingDate || this?.testData?.ClosingDate    || format(new Date(), 'MMM-dd-yyyy');  await ui.fill('quick.closingDate', closing);  await ui.selectByLabel('quick.agent.select',    this?.__dealRow?.Agent || this?.testData?.Agent || 'Scotia Admin');  const mort = this?.__dealRow?.MortgageAmount || this?.testData?.MortgageAmount    || fake.numberInRange(200000, 2000000, 0);  await ui.fill('quick.mortgageAmount', String(mort));  await ui.click('quick.save.button');});/* ----------------------- Additional Borrowers ----------------------- */When('I fill additional borrowers', async function () {  const attach = typeof this.attach === 'function' ? this.attach.bind(this) : async () => {};  const ui = new UI(this.page, attach);  // Proactively open Borrowers panel (fast path)  await ui.ensureBorrowersOpen();  await attach('Borrowers panel is open.');  // Collect applicant IDs; skip blanks  const s = this.testData || {};  let ids = [    s.SecondApplicantID, s.ThirdApplicantID, s.FourthApplicantID,    s.FifthApplicantID, s.SixthApplicantID,  ]    .map(v => (v ?? '').toString().trim())    .filter(Boolean);  // de-duplicate to avoid adding the same applicant twice if sheet repeats  ids = Array.from(new Set(ids));  // Optional cap in case UI enforces a maximum number of borrowers  const maxCap = Number.isFinite(Number(this?.parameters?.maxBorrowers))    ? Number(this.parameters.maxBorrowers)    : (Number.isFinite(Number(process.env.MAX_BORROWERS)) ? Number(process.env.MAX_BORROWERS) : Infinity);  if (Number.isFinite(maxCap)) ids = ids.slice(0, maxCap);  if (ids.length === 0) {    await attach('No additional applicants in scenario row; nothing to add.');    return;  }  // Profiles will be handled in Phase 2; no primary pre-fill here  const getDetail = async (id) => {    try { return await getApplicantDetail(this, id); }    catch (e) { await attach(`Lookup failed for "${id}": ${e?.message || e} — using Faker.`); return null; }  };  // Loose lookup that tolerates missing Title/CASL and still returns a DataBag  const getDetailLoose = async (id) => {    try {      const bag = await Data.fromApplicantId(this, id);      if (bag) return bag;      await attach(`ApplicantsCatalog has no row for "${id}" — using Faker.`);      return null;    } catch (e) {      await attach(`Applicant lookup issue for "${id}": ${e?.message || e} — using Faker.`);      return null;    }  };  const openAddBorrowerModal = async () => {    await ui.ensureBorrowersOpen();    // click with a tiny retry if modal doesn't show up immediately    for (let attempt = 1; attempt <= 3; attempt++) {      await ui.click('Borrowers.addBorrower');      try {        await ui.expectVisible('Borrowers.modal.root', 3000);        return;      } catch {        await attach(`Add Borrower click attempt ${attempt} — modal not visible yet, retrying...`);        // Refresh the panel (collapse + expand) to heal UI state, then retry        await ui.refreshBorrowersPanel();        await this.page.waitForTimeout(250);      }    }    await ui.expectVisible('Borrowers.modal.root', 3000);  };  // Phase 1: Add all additional borrowers (batch)  for (let idx = 0; idx < ids.length; idx++) {    const id = ids[idx];    // Prefer loose lookup; fallback to strict only if needed for diagnostics    const applicant = (await getDetailLoose(id)) || (await getDetail(id));    // If the Add Borrower button is no longer available, stop gracefully    try {      const present = await ui.exists('Borrowers.addBorrower', 1500);      if (!present) {        await attach('Add Borrower not available — reached limit or UI state changed. Stopping.');        break;      }    } catch {}    const first = Data.get(applicant, 'FirstName') || fake.getFirstName();    const last  = Data.get(applicant, 'LastName')  || fake.getLastName();    const email = Data.get(applicant, 'Email')     || fake.getEmail();    const dob   = Data.get(applicant, 'DateOfBirth');    const full = [first, last].filter(Boolean).join(' ');    await attach(`Adding borrower ${id} — "${full}" (email=${email}${dob ? `, dob=${dob}` : ''})`);    // 1) Open modal    await openAddBorrowerModal();    // 2) Fill fields inside modal    await ui.within('Borrowers.modal.root').fill('Borrowers.modal.firstName', first);    await ui.within('Borrowers.modal.root').fill('Borrowers.modal.lastName', last);    if (email) await ui.within('Borrowers.modal.root').fill('Borrowers.modal.email', email);    if (dob) await ui.within('Borrowers.modal.root').fill('Borrowers.modal.dob', dob);    try { await ui.within('Borrowers.modal.root').check('Borrowers.modal.casl'); } catch {}    try { await ui.within('Borrowers.modal.root').selectByLabel('Borrowers.modal.contactPref', 'Email'); } catch {}    // 3) Save + wait for modal to close    await ui.within('Borrowers.modal.root').click('Borrowers.modal.ok');    await ui.ensureModalSaved('Borrowers.modal.root', { timeout: 12000 });    await attach(`Borrower saved: ${full}`);    // 3b) Phase 1 only adds borrowers; fill details later in Phase 2
    // 4) Debounce; if more borrowers remain, ensure panel is open and button present    await this.page.waitForTimeout(300);    const moreRemain = idx < ids.length - 1;    if (moreRemain) {      try {        const present = await ui.exists('Borrowers.addBorrower', 1500);        if (!present) {          await attach('Add Borrower not available after save — stopping further additions.');          break;        }      } catch {}      await ui.ensureBorrowersOpen();    }  }  // Phase 2: Fill profiles for all borrowers (primary + additionals) using ApplicantsCatalog  try {    const allIds = [ String(this?.testData?.PrimaryApplicantID || '').trim(), ...ids ].filter(Boolean);    if (allIds.length) {      await ui.ensureBorrowersOpen();      // Clamp to actual tab count to avoid overshoot when Add Borrower disappears      let tabNames = [];      try { tabNames = await ui.listBorrowerTabs(); } catch {}      const uiCount = Array.isArray(tabNames) ? tabNames.length : 0;      const loopCount = uiCount > 0 ? Math.min(allIds.length, uiCount) : allIds.length;      for (let i = 0; i < loopCount; i++) {        const id = allIds[i];        const applicant = (await Data.fromApplicantId(this, id)) || Data.bag({});        await ui.selectBorrowerTab(i + 1); // tabs are 1-based in UI        await ui.withinActiveBorrower();        const { fillBorrowerProfileFromApplicant, fillCurrentAddressFromApplicant, expandEmployment } = require('../../src/tasks/borrowers');        await fillBorrowerProfileFromApplicant(ui, applicant);        const addrOk = await fillCurrentAddressFromApplicant(ui, applicant, { faker: fake });        await attach(addrOk ? `Address filled for borrower #${i + 1}` : `Address not selected for borrower #${i + 1} (manual/empty)`);        try { await expandEmployment(ui); } catch {}        await attach(`Completed details for borrower #${i + 1} (${id})`);      }    }  } catch (e) {    await attach(`Profile fill phase encountered an issue: ${e?.message || e}`);  }});